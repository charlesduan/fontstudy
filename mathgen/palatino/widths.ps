%!PS-Adobe-2.0
%%Pages: (atend)
%%EndComments
%%BeginProlog
%%BeginResource: functions.ps
%!PS-Adobe-2.0

%
% functions.ps
%
% Convenience functions for me, that I think are useful in multiple files.
%

% An inch
/inch { 72 mul } bind def

% Given a dictionary, print its keys. Leaves the dictionary on the stack.
/pkeys {
    dup { pop == } forall
} bind def

% Given a set of pairs 1 2 3 4 5 6 and a number of pairs 3, pulls pairs out and
% leaves 1 3 5 2 4 6 on the stack.
/seppairs {
    2 dict begin
    dup array /Evens exch def
    dup array /Odds exch def
    1 sub -1 0 {	% odd even index
	dup Odds exch	% odd even index Odds index
	5 2 roll	% Odds index odd even index
	Evens exch	% Odds index odd even Evens index
	3 -1 roll	% Odds index odd Evens index odd
	put put
    } for
    Odds aload pop Evens aload pop
    end
} def

% Min/max functions
/min { 2 copy gt { exch } if pop } bind def
/max { 2 copy lt { exch } if pop } bind def

% Given a number and a base/bounds, determine whether that number falls within
% the base/bounds. Accept all possible values for both base and bounds,
% including negative.
% value base bounds -- bool
% Add a tolerance value to base and bounds, because sometimes the
% floating-point arithmetic is a bit off.
/withinRange {
    dup 0 gt {
	% If bounds is positive. value - base >= 0 and <= bounds.
	3 1 roll sub	% bounds value-base
	dup 0 ge {
	    ge
	} {
	    pop pop false
	} ifelse
    } {
	% If bounds is negative, value - base <= 0 and >= bounds.
	3 1 roll sub
	dup 0 le {
	    le
	} {
	    pop pop false
	} ifelse
    } ifelse
} def

% Append two strings.
/append {
     2 copy length exch length add  % find the length of the new.
     string dup     % string1 string2 string string
     4 2 roll       % string string string1 string2
     2 index 0 3 index
     % string string string1 string2 string 0 string1
     putinterval    % stuff the first string in.
     % string string string1 string2
     exch length exch putinterval
} bind def

% Sorts an array using a comparator function. The specification of the
% comparator function is as follows:
%
% Takes two arguments. Returns TRUE iff the two arguments are in the correct
% order in their presentation; false otherwise.
%
% The array is sorted IN PLACE; that is, its contents will be overwritten. If
% this is not desired behavior, place at the beginning of the call:
%
% dup length array copy
%
% [array] {proc} -- [array]
/bubblesort {
    4 dict begin
	/proc exch def
	/ary exch def
	ary length 2 sub -1 0 {
	    /noexch true def
	    0 1 3 -1 roll {
		/pos exch def
		ary pos get ary pos 1 add get 2 copy proc not {
		    ary exch pos exch put
		    ary exch pos 1 add exch put
		    /noexch false def
		} {
		    pop pop
		} ifelse
	    } for
	    noexch { exit } if
	} for
	ary
    end
} def

% Reverses an array.
/revArray {
    2 dict begin
	/ary exch def
	/len ary length 1 sub def
	0 1 ary length 2 idiv 1 sub {
	    dup len exch sub ary exch get	% i ary[len-i]
	    ary 2 index get			% i ary[len-i] ary[i]
	    ary 3 index len exch sub 3 -1 roll	% i ary[len-i] ary len-i ary[i]
	    put ary 3 1 roll put
	} for
	ary
    end
} def

% Puts an array onto the stack.
/loadArray { aload pop } bind def

% Get the first or last element of an array.
/firstElt { 0 get } bind def
/lastElt { dup length 1 sub get } bind def

% Iterates several times.
% num { proc } --
/iterate {
    /IterateProc exch def
    -1 0 { pop IterateProc } for
} def
%%EndResource
%%BeginResource: points.ps
%!PS-Adobe-2.0

%
% points.ps
%
% Utility functions for points.
%

% Requires: functions.ps

% Given a pair of points, determines the average of them.
% x1 y1 x2 y2 -- x1+x2/2 y1+y2/2
/avgPoint {
    3 -1 roll add 2 div 3 1 roll add 2 div exch
} bind def

% Given a pair of points and a tolerance, determine whether the second point is
% within the tolerance range of the first point. Tolerance should be >= 0.
% x1 y1 x2 y2 tol -- bool
/eqPoint {
    dup 6 2 roll	% tol tol x1 y1 x2 y2
    3 -1 roll		% tol tol x1 x2 y2 y1
    sub	abs		% tol tol x1 x2 |y2-y1|
    3 1 roll		% tol tol dy x1 x2
    sub abs		% tol tol dy dx
    3 1 roll		% tol dx tol dy
    ge			% tol dx bool
    3 1 roll ge and
} bind def

% Given two points, tests them for exact equality.
/equalPoint {
    3 -1 roll eq 3 1 roll eq and
} bind def

% Scales a point by a constant.
% x1 y1 scale -- x y
/scalePoint {
    dup 3 1 roll mul 3 1 roll mul exch
} bind def

% Add two points.
% x1 y1 x2 y2 -- x y
/addPoint {
    3 -1 roll add 3 1 roll add exch
} bind def

% Subtract two points.
/subPoint {
    3 -1 roll exch sub 3 1 roll sub exch
} bind def

% Performs a dot product on 2d points.
/dotProduct {
    3 -1 roll mul 3 1 roll mul add
} bind def

/magnitude {
    dup mul exch dup mul add sqrt
} bind def

% Iterates over a list of points. The point list is a list of 2-element lists.
/ForallPointDict 1 dict def

/forallPoint {
    % We must make a global definition here, because without it we need to store
    % the procedure on a local dictionary (which violates the nature of forall)
    % or leave the procedure on the stack (which violates the nature of forall).
    ForallPointDict exch /fp exch put
    {
        aload pop ForallPointDict /fp get exec
    } forall
} def

% Given a pair of coordinates, get one of them. These are really stupid
% functions, but they make the code easier to read.
/xcoor { dup type /arraytype eq { 0 get } { pop } ifelse } bind def
/ycoor { dup type /arraytype eq { 1 get } { exch pop } ifelse } bind def

% Sorts an array of points by x or y coordinate, ascending.
/sortByX {
    { xcoor exch xcoor exch lt } bubblesort
} def

/sortByY {
    { ycoor exch ycoor exch lt } bubblesort
} def

% Given a user path and a list of points, gives the points that are in the fill
% region of the user path (by inufill).
% [ [points] ] { upath } -- [ [points subset] ]
/pointsInRegion {
    1 dict begin
	cvlit /ThePath exch def
	[ exch {
	    2 copy ThePath inufill {
		[ 3 1 roll ]
	    } {
		pop pop
	    } ifelse
	} forallPoint
	]
    end
} def

% Defines a point.
/defPoint {
    dup type /nametype eq {
	1 index type /arraytype eq { exch aload pop } { 3 1 roll } ifelse
    } if
    2 packedarray cvx def
} def

% If two points are too close for comfort, discard one of them.
% [ [ point list ] ] -- [ [ subset ] ]
/uniquePoints {
    5 dict begin
    /theArray exch def
    /newArray [ ] def
    0 1 theArray length 1 sub {
	theArray exch get loadArray /curPoint defPoint
	/noMatches true def
	0 1 newArray length 1 sub {
	    newArray exch get loadArray curPoint 3 eqPoint {
		/noMatches false def
		exit
	    } if
	} for
	noMatches {
	    /newArray [ newArray aload pop [ curPoint ] ] def
	} if
    } for
    newArray
    end
} def
%%EndResource
%%BeginResource: angles.ps
%!PS-Adobe-2.0

%
% angles.ps
%
% Fun tricks for curve segments and angles.
%

% Requires: functions.ps points.ps

% Given two points, finds the angle in degrees from the horizontal of the line
% defined ending at the first point.
% x1 y1 x2 y2 -- angle of vector from (x1,y1) to (x2, y2)
/lineAngle {
    4 2 roll subPoint exch atan
} bind def

% Given a curveto (8 arguments), get the starting angle. This will be the
% direction the curve starts out traveling.
/curveStartAngle {
    pop pop pop pop
    lineAngle
} def

% Given a curveto (8 arguments), get the ending angle. This will be the
% direction the curve would continue to travel in if it didn't stop.
/curveEndAngle {
    lineAngle 5 1 roll
    pop pop pop pop
} def

% Takes two points p and q and an angle theta. Pretend that an angle was drawn
% with a circular pen of radius r. If the pen had zero radius, then the path
% would have angled at p with an angle of theta. But because the radius is
% greater than zero, the "angle" occurs at point q. This function will return
% the diameter 2*r.
%            /
%           /*
%          / |
%         /  `.   ..*|
%        /    q.-^   | r
%       /       \.   |
%      /theta     ^*.|
%     p----------------
%
/penDiameter {
    2 div sin 5 1 roll subPoint magnitude	% sin(theta/2) l
    1 index mul exch				% l*sin sin
    1 exch sub div				% l*sin / (1-sin) = r
    2 mul
} def

%
% Given a box, defined by lower left and upper right points, and a point and an
% angle, draw the line that fits in the bounding box, goes through that point,
% and travels at that angle.
%
% +------------------+
% | \                |
% |  \               |
% |   \ theta        |
% |    p-------      |
% |     \            |
% |      \           |
% |       \          |
% +------------------+
%
/boundedLine {
    6 dict begin
	{ dup 0 ge { exit } if 180 add } loop
	{ dup 180 lt { exit } if 180 sub } loop
	/Theta exch def
	/Point defPoint
	% If the angle is over 90 degrees, swap left and right for convenience
	2 seppairs 2 copy max /BoxTop exch def min /BoxBot exch def
	2 copy max /BoxRt exch def min /BoxLft exch def
	% First, the upper intersection point.
	% Degenerate cases: point is on top of box and angle is horizontal
	Point ycoor BoxTop eq
	% Point is on side of box and angle is vertical
	90 Theta eq Point xcoor BoxRt eq Point xcoor BoxLft eq or and
	or {
	    Point
	} {
	    Point BoxRt BoxTop lineAngle Theta ge {
		BoxRt Point xcoor sub % horizontal distance
		dup Theta sin mul Theta cos div % vertical distance
		Point addPoint
	    } {
		Point BoxLft BoxTop lineAngle Theta ge {
		    BoxTop Point ycoor sub
		    dup Theta cos mul Theta sin div
		    exch Point addPoint
		} {
		    BoxLft Point xcoor sub % horizontal distance
		    dup Theta sin mul Theta cos div % vertical distance
		    Point addPoint
		} ifelse
	    } ifelse
	} ifelse
	% Lower point.
	% Degenerate cases: point is on top of box and angle is horizontal
	Point ycoor BoxBot eq
	% Point is on side of box and angle is vertical
	90 Theta eq Point xcoor BoxLft eq Point xcoor BoxRt eq or and
	or {
	    Point
	} {
	    /Theta Theta 180 add def
	    Point BoxLft BoxBot lineAngle Theta ge {
		BoxLft Point xcoor sub % horizontal distance
		dup Theta sin mul Theta cos div % vertical distance
		Point addPoint
	    } {
		Point BoxRt BoxBot lineAngle Theta ge {
		    BoxBot Point ycoor sub
		    dup Theta cos mul Theta sin div
		    exch Point addPoint
		} {
		    BoxRt Point xcoor sub % horizontal distance
		    dup Theta sin mul Theta cos div % vertical distance
		    Point addPoint
		} ifelse
	    } ifelse
	} ifelse
    end
} def

% Line bounded by the current path's bounding box. Takes a point and an angle.
/bboxLine {
    pathbbox 5 5 addPoint 4 2 roll 5 5 subPoint 4 2 roll 7 4 roll boundedLine
} def
%%EndResource
%%BeginResource: extremes.ps
%!PS-Adobe-2.0

%
% extremes.ps
%
% Functions for manipulating extremes.
%

2 dict begin

    /pointList [ ] def

    /addPoint {
	[ 3 1 roll ] [ exch pointList aload pop ] /pointList exch def
    } def

currentdict
end
/ExtremesDict exch def


% Now, the public interface

% Given a coordinate pair, test it as an extreme point candidate. Require that
% the point be within the clipping path for consideration.
/cmpPoint {
    ExtremesDict begin
	addPoint
    end
} def

% Clear out the current extreme values.
/resetExtremes {
    ExtremesDict begin
	/pointList [ ] def
    end
} def
%%EndResource
%%BeginResource: intersect.ps
%!PS-Adobe-2.0

%
% intersect.ps
%

% Requires: functions.ps

% Given four absolute points, determine the intersection between the lines.
% x1 y1 x2 y2 x3 y3 x4 y4 -- x y true OR false
% The first line is the one between (x1,y1) and (x2,y2).
/intersect {
    16 dict begin
	4 seppairs
	% Given a pair of x or y coordinates, a parametrization of the line
	% segment defined by them is {x,y} = mt + b, where b is one of the
	% coordinates and m is the difference between the two of them.
	dup /yb1 exch def sub /ym1 exch def
	dup /yb2 exch def sub /ym2 exch def
	dup /xb1 exch def sub /xm1 exch def
	dup /xb2 exch def sub /xm2 exch def
	% It turns out that the solution for the intersection is:
	%      xm2(yb1-yb2) + ym2(xb2-xb1)
	% t1 = ---------------------------
	%           xm1 ym2 - xm2 ym1
	%      xm1(yb1-yb2) + ym1(xb2-xb1)
	% t2 = ---------------------------
	%           xm1 ym2 - xm2 ym1
	%
	% Let's hope we code this right...
	xm1 ym2 mul xm2 ym1 mul sub	% Denominator
	/Denom exch def
	yb1 yb2 sub xb2 xb1 sub		% factor1 factor2
	2 copy
	ym2 mul exch xm2 mul add	% f1 f2 t1-numerator
	/t1num exch def
	ym1 mul exch xm1 mul add	% t2-num
	/t2num exch def
	% If we've got coinciding lines, just take the middle
	t1num 0 eq
	Denom 0 eq
	and {
	    false
	} {
	    % Now we perform range checks. The numerators should each be at
	    % least zero and no more than D.
	    t1num 0 Denom withinRange t2num 0 Denom withinRange and {
		% If true, then we simply plug in t1 into its respective x and y
		% equations to get x and y values.
		t1num Denom div dup
		xm1 mul xb1 add exch
		ym1 mul yb1 add
		true
	    } {
		false
	    } ifelse
	} ifelse
    end
} def


%%EndResource
%%BeginResource: bzfunc.ps
%!PS-Adobe-2.0

%
% bzfunc.ps
%
% Bezier curve functions
%

% Requires: functions.ps

% Our bezier curve functions. Given the x or y coordinates and a t value,
% calculate the value at that point.
% x0 x1 x2 x3 t -- x
/bezierFunc {
    2 dict begin
    /t exch def
    /s 1 t sub def
    t mul t mul t mul			% x3 * t^3
    exch t mul t mul s mul 3 mul add	% x2 * 3t^2(1-t)
    exch s mul s mul t mul 3 mul add	% x1 * 3t(1-t)^2
    exch s mul s mul s mul add		% x0 * (1-t)^3
    end
} def

% Given four points and t, calculate the bezier function at that value t.
% x1 y1 x2 y2 x3 y3 t -- x y
/curvetoPoint {
    dup 5 seppairs	% x0 x1 x2 x3 t y0 y1 y2 y3 t
    bezierFunc 6 1 roll
    bezierFunc exch
} def

% Finds the Bezier extrema.
% x0 x1 x2 x3 -- [ values ]
% where values is, for each extreme, the value t. We assume that x0 = 0.
/bezierExtremes {
    6 dict begin
	% Originally, this function assumed rcurveto semantics, so a would
	% always be 0. But pathforall uses curveto instead. Since we don't want
	% to do all the math all over again, we collect a first, and then make
	% all the values relative. It makes no difference, since the value we
	% return, time, is independent of the relative location of the curve.
	4 -1 roll
	/a exch def

	% Define the four parameters
	/d exch a sub def
	/c exch a sub def
	/b exch a sub def

	% The function is:
	%   3bt(1 - t)^2 + 3ct^2(1 - t) + dt^3
	% Its derivative is (divided by three):
	%   b - 4bt + 2ct + 3bt^2 - 3ct^2 + dt^2
	% Which means the zero point is:
	%       (2b-c) +- sqrt( b(b-c-d) + c^2)
	%   t = -------------------------------
	%               3b - 3c + d
	% (the quadratic formula divided all over by two).
	% Let B=2b-c, det=b(b-c-d)+c^2, and A=3b-3c+d.
	/det b c sub d sub b mul c c mul add def
	/A b 3 mul c 3 mul sub d add def
	/B b 2 mul c sub def

	A 0 eq {
	    % If we've got a straight line on our hands; i.e., A=0
	    % Then the function is:
	    %   0 = 2(c-2b)t + b
	    %   b = 2(2b-c)t
	    %   t = b / 2(2b-c) = b / 2B
	    B 0 eq {
		% If B=0, then no solution, because it's horizontal
		[ ]
	    } {
		% Otherwise it's at -c / -B. Recall we must add a back to the
		% resulting value.
		[
		    b B 2 mul div dup 0 1 withinRange not { pop } if
		]
	    } ifelse
	} {
	    det 0 le {
		% If the determinant is negative, there is no solution. If it's
		% zero leave nothing on the stack, since the point we've found
		% is neither a max nor a min.
		[ ]
	    } {
		% Leave -B[+-]sqrt(det)/2A 2 on the stack. Recall we must add a
		% back to the resulting value.
		[
		    B det sqrt add A div dup 0 1 withinRange not { pop } if
		    B det sqrt sub A div dup 0 1 withinRange not { pop } if
		]
	    } ifelse
	} ifelse
    end
} def

% Returns the two extremes arrays, x extremes and then y extremes.
% x0 x1 x2 x3 y0 y1 y2 y3 -- [ x ] [ y ]
/curvetoExtremes {
    4 seppairs
    bezierExtremes 5 1 roll bezierExtremes exch
} def

%%EndResource
%%BeginResource: bzintc.ps
%!PS-Adobe-2.0

%
% bzintc.ps
%
% Intersection between a Bezier curve and a line.
%
% IMPLEMENTATION NOTE: while we could solve this problem systematically--the
% cubic equation is solvable--the solution is over 2 pages long and takes about
% a minute to derive for Mathematica. Instead, we derive it by picking out
% segments from the Bezier curve and finding intersections via interpolation.
%

% Requires: bzfunc.ps intersect.ps


% Takes curveto arguments (4 points) and two points defining a line segment for
% intersection.
/curvetoIntc {
    10 dict begin
	% Collect up the first four args, the line segment point
	4 packedarray cvx /LineSegment exch def
	% Collect up the next 8 args, the curve definition points
	8 packedarray cvx /CurvePoints exch def
	% Counter for how many intersections we've found. The tryCurveIntc
	% function will leave the points on the stack.
	/NumPoints 0 def
	/ThisDict currentdict def
	/AddPoint {
	    ThisDict dup /NumPoints get 1 add /NumPoints exch put
	} bind def
	/RecursiveDepth 0 def
	0 0.05 1 tryCurveIntc
	NumPoints
    end
} def

% Helper function for rcurvetoIntc. Assumes /LineSegment and /CurvePoints to
% exist in some dictionary. Takes for-like arguments (init, delta, final) on the
% stack, iterates over them, and searches for intersection points.
% init delta final -- points
/tryCurveIntc {
    4 dict begin
	/RecursiveDepth RecursiveDepth 1 add def
	exch dup /Delta exch def exch
	3 copy exch 2 div add exch	% i d f f+d/2 i
	dup /LastT exch def		% Save i to lastT
	CurvePoints 9 -1 roll curvetoPoint
	2 packedarray cvx /LastPoint exch def % Using initial, get Bezier point
	exch pop	% Kill original final; use augmented one
	{	% Begin for loop
	    dup						% t t
	    CurvePoints 9 -1 roll curvetoPoint		% t x y
	    2 copy LastPoint LineSegment intersect {	% t x y x-intc y-intc
		% If we found an intersection
		2 copy LastPoint 0.1 eqPoint RecursiveDepth 1000 gt or {
		    % If the point happens to be close enough to LastPoint, then
		    % we'll consider it good.
		    AddPoint
		    5 2 roll
		} {
		    % If they're too far apart, then we're in trouble. Using
		    % LastT and T, we'll recursively call this function.
		    pop pop			% t x y
		    3 -1 roll dup 4 2 roll	% t t x y
		    % Save off t, x, y, so whatever recursive tryCurveIntc does,
		    % we can replace our old values at the top of the stack.
		    3 packedarray cvx /Save exch def
		    LastT exch 2 copy 		% LastT t LastT t
		    exch sub 5 div		% LastT t (t-LastT)/5
		    exch
		    tryCurveIntc
		    Save
		} ifelse
	    } if					% t x y
	    2 packedarray cvx /LastPoint exch def
	    /LastT exch def
	} for
    end
} def
%%EndResource
%%BeginResource: intcmgr.ps
%!PS-Adobe-2.0

%
% intcmgr.ps
%
% Manages intersections between a line and various curves.
%

% Requires: intersect.ps bzintc.ps functions.ps

10 dict begin

    % Place where points will be stored.
    /pointList [ ] def

    /addPoint {
	[ 3 1 roll ] [ exch pointList aload pop ] /pointList exch def
    } def

    % Line to check for intersections.
    %/intcLine { 0 0 0 0 } def

currentdict
end
/IntersectDict exch def

% Resets the intersection manager.
/resetIntc {
    IntersectDict begin
	/pointList [ ] def
    end
} def

% Sets the line to test against other points.
/setIntcLine {
    IntersectDict begin
	4 packedarray cvx /intcLine exch def
    end
} def

% Basically performs "intersect", but saves the result value.
/intcLines {
    IntersectDict begin
	intcLine intersect {
	    addPoint
	} if
    end
} def

% Performs curvetoIntc, calculates the actual intersection point, and saves the
% result.
/intcCurve {
    IntersectDict begin
	intcLine curvetoIntc -1 1 {
	    pop addPoint
	} for
    end
} def

% Iterates over the points collected.
/intcForall {
    IntersectDict /pointList get exch forallPoint
} def

% Shows the intersection line (without messing up the path)
/showIntcLine {
    IntersectDict begin
    gsave
	newpath intcLine moveto lineto stroke
    grestore
    end
} def
%%EndResource
%%BeginResource: drawing.ps
%!PS-Adobe-2.0

%
% drawing.ps
%
% Drawing stuff.
%

/pointbox {
    gsave
	newpath moveto
	-10 -10 rlineto
	20 0 rlineto
	closepath fill
    grestore
} bind def
/uppointbox {
    gsave
	newpath moveto
	-10 10 rlineto
	20 0 rlineto
	closepath fill
    grestore
} bind def
/rtpointbox {
    gsave
	newpath moveto
	10 -10 rlineto
	0 20 rlineto
	closepath fill
    grestore
} bind def
/ltpointbox {
    gsave
	newpath moveto
	-10 10 rlineto
	0 -20 rlineto
	closepath fill
    grestore
} bind def

/drawHorizLine {
    gsave
	3 setlinewidth
	newpath dup 0 exch moveto
	700 exch lineto
	stroke
    grestore
} def

/drawLine {
    gsave 4 copy moveto lineto stroke grestore
} def


%%EndResource
%%BeginResource: pathtricks.ps
%!PS-Adobe-2.0

%
% pathtricks.ps
%
% Methods for manipulating paths.
%
% All of the functions in this package assume that there is a current path. They
% do not change the path at all.
%

% Requires: extremes.ps intcmgr.ps points.ps drawing.ps angles.ps

% General method for executing pathforall in a useful method such that
% currentpoint works correctly. Expects methods linetoHook, movetoHook,
% curvetoHook, and closepathHook to exist. If startingHook and/or endingHook are
% defined, then they will be executed at the appropriate times.
%
/tracePath {
    10 dict begin	% Save the starting X and Y; also makes hooks local
    gsave
    /startingHook where {
	pop startingHook
    } if
    {		% moveto
	2 copy mark 3 1 roll movetoHook cleartomark
	/startPoint defPoint
	/curPoint startPoint defPoint
    } {		% lineto
	2 copy mark 3 1 roll linetoHook cleartomark
	/curPoint defPoint
    } {		% curveto
	6 copy mark 7 1 roll curvetoHook cleartomark
	/curPoint defPoint
	pop pop pop pop
    } {		% closepath
	mark startPoint linetoHook cleartomark
	mark closepathHook cleartomark	% just in case
	/curPoint startPoint defPoint
    } pathforall
    /endingHook where {
	pop endingHook
    } if
    grestore
    end
} def

%
% INTERSECTIONS
%

% Dictionary defining hooks for line intersections. It is expected that the user
% of this dictionary initialize the line for the intersection manager.
5 dict begin
    /movetoHook { pop pop } def
    /linetoHook {
	curPoint intcLines
    } def
    /curvetoHook {
	curPoint 8 2 roll
	intcCurve
    } def
    /closepathHook { } def
currentdict
end
/PathIntcDict exch def

% Given the points for a line, determine an intersection.
/pathLineIntc {
    resetIntc
    PathIntcDict begin
	setIntcLine
	showIntcLine
	tracePath
    end
    IntersectDict /pointList get
    uniquePoints
} def

% EXTREME VALUES

5 dict begin
    /movetoHook { pop pop } def
    /linetoHook {
	curPoint cmpPoint
	cmpPoint
    } def
    /curvetoHook {
	2 copy cmpPoint
	curPoint cmpPoint
	curPoint 8 2 roll
	8 packedarray cvx /points exch def
	points curvetoExtremes
	{ points 9 -1 roll curvetoPoint cmpPoint } forall
	{ points 9 -1 roll curvetoPoint cmpPoint } forall
    } def
    /closepathHook { } def
currentdict
end
/PathExtrDict exch def

% Determine the extremes.
/pathExtremes {
    resetExtremes
    PathExtrDict begin
	tracePath
    end
    ExtremesDict /pointList get
} def


% Direction of fill
%
% Given an array of points and a point offset, extracts those points that, when
% the offset is applied to them, 
% [ point array ] offx offy -- [ point array subset ]
/offsetInFill {
    1 dict begin
	2 packedarray cvx /offset exch def
	[ exch
	{
	    2 copy offset addPoint infill {
		[ 3 1 roll ]
	    } {
		pop pop
	    } ifelse
	} forallPoint
	]
    end
} def

% Midpoint of the current path.
/pathMidpoint {
    pathbbox 2 seppairs add 2 div 3 1 roll add 2 div exch
} def

% Upper right coordinate of current path.
/pathUR {
    pathbbox 4 2 roll pop pop
} def

% Path lower left coordinate.
/pathLL {
    pathbbox pop pop
} def

% Vertical line that splits the bbox in half. Leaves the coordinates on the
% stack.
/vertSplitLine {
    dup pathUR xcoor mul	% frac frac*llx
    exch 1 exch sub		% frac*llx 1-frac
    pathLL xcoor mul		% frac*llx (1-frac)*urx
    add dup			% avgX avgX
    pathLL ycoor 10 sub exch
    pathUR ycoor 10 add
} def
/horizSplitLine {
    dup pathUR ycoor mul	% frac frac*lly
    exch 1 exch sub		% frac*lly 1-frac
    pathLL ycoor mul		% frac*lly (1-frac)*ury
    add				% avgY avgY
    pathLL xcoor 10 sub exch
    pathUR xcoor 10 add 1 index
} def

/vertLineThrough {
    xcoor dup
    pathLL ycoor 10 sub exch
    pathUR ycoor 10 add
} def
/horizLineThrough {
    ycoor
    pathLL xcoor 10 sub exch
    pathUR xcoor 10 add 1 index
} def

% Show a letter.
/letterPath {
    newpath 0 0 moveto true charpath
    gsave stroke grestore
} bind def



%
% ANGLE AT A POINT IN THE PATH
%
6 dict begin
/movetoHook { pop pop } def
/linetoHook {
    /theAngle where {
	pop pop pop
    } {
	curPoint 4 2 roll
	4 copy thePoint linePtIntc {
	    pop pop lineAngle /theAngle exch def
	} if
    } ifelse
} def
/curvetoHook { } def	% Should never occur, since we flatten the path
/closepathHook { } def
/endingHook { /theAngle where dup { exch pop theAngle exch } if } def
currentdict
end
/PathAngleDict exch def

/pathAngle {
    PathAngleDict begin
    gsave
	flattenpath
	/thePoint defPoint
	tracePath
    grestore
    end
} def

% Produces the coordinates for a perpendicular through a given point.
/perpThroughPoint {
    90 add bboxLine
} def

% Measure height/depth of the path.
/measureHeight {
    gsave
	flattenpath pathUR ycoor
	dup drawHorizLine
    grestore
} def
/measureDepth {
    gsave
	flattenpath pathLL ycoor
	dup drawHorizLine
	neg
    grestore
} def


%%EndResource
%%BeginResource: bracket.ps
%!PS-Adobe-2.0
%
% bracket.ps
%
% Given the darkness parameter, a point on the stem, the edge of the serif, and
% the corner where the stem and the edge should meet with no bracket, finds the
% height of the bracket.
%
% Requires: points.ps pathtricks.ps drawing.ps
%
/findBracket {
    4 dict begin
	/corner defPoint	% Point where the serif and stem meet
	/edge defPoint		% Point at top end of serif
	/bracket defPoint	% Point where bracket should end
	/fraction exch 1 exch div def	% Darkness parameter (usually 1/3)
	10 {
	    edge bracket drawLine avgPoint corner
	    pathLineIntc dup length 0 eq {
		/bracket corner defPoint
		pop exit
	    } if
	    firstElt loadArray % Better only have one element!
	    corner subPoint fraction scalePoint corner addPoint
	    % First line for the intersection, that goes through edge. This line
	    % should intersect the stem line at the bracket point.
	    edge subPoint 10 scalePoint edge addPoint edge
	    % Second line for the intersection
	    bracket corner subPoint 20 scalePoint corner addPoint corner
	    intersect {
		/bracket defPoint
	    } {
		/bracket corner defPoint
		exit
	    } ifelse
	} iterate
	bracket pointbox
	mark bracket edge drawLine avgPoint corner drawLine cleartomark
	bracket
    end
} def


%%EndResource
%%BeginResource: pointintc.ps
%!PS-Adobe-2.0

%
% pointintc.ps
%
% Determines when a point intersects with a line or a curve.
%

% Requires: functions.ps points.ps bzintc.ps

% The tolerance range for intersections. By default 3 points.
/PtIntcEps 3 def

% Makes a line segment given one of the points and a true/false value for which
% direction to draw the line.
/epsilonLine {
    {
	2 copy
	PtIntcEps 0 addPoint 4 2 roll
	PtIntcEps 0 subPoint
    } {
	2 copy
	0 PtIntcEps addPoint 4 2 roll
	0 PtIntcEps subPoint
    } ifelse
} def

% Given a line segment, does it intersect /pt1?
% x1 y1 x2 y2 x y -- false OR x' y' true
/linePtIntc {
    5 dict begin
	/p defPoint
	/p1 defPoint
	/p2 defPoint
	/p2top p p2 subPoint defPoint
	/p2top1 p1 p2 subPoint defPoint
	/p2top1mag p2top1 magnitude def
	p2top magnitude p1 p subPoint magnitude add p2top1mag sub
	-1 2 withinRange {
	    p2top1mag 0 eq {
		p1 true
	    } {
		p2top1
		p2top p2top1 dotProduct p2top1mag dup mul div
		0 max 1 min
		scalePoint
		p2 addPoint true
	    } ifelse
	} {
	    false
	} ifelse
    end
} def

/ifCurveIntc {
    curvetoIntc dup 0 gt {
	-1 2 {
	    pop pop pop
	} for
	true
    } {
	pop false
    } ifelse
} def

% Does a curve intersect?
% x1 y1 ... x8 y8 x y -- x y true OR false
/curvePtIntc {
    10 copy true epsilonLine ifCurveIntc {
	12 2 roll
	pop pop pop pop pop pop pop pop pop pop	% 10 of them
	true
    } {
	false epsilonLine ifCurveIntc
    } ifelse
} def

%%EndResource
%%BeginResource: subpath.ps
%!PS-Adobe-2.0

%
% subpath.ps
%
% Produces subpaths based on starting and ending conditions.
%

% Requires: angles.ps pointintc.ps


% Makes a subpath, as a user path.
/traceSubpath {
    20 dict begin	% Save the starting X and Y; also makes hooks local
    /moveto { /moveto cvx } def
    /lineto { /lineto cvx } def
    /curveto { /curveto cvx } def
    /closepath { /closepath cvx } def
    % Execute the initialization hook, which should be at the top of the stack.
    exec
    [
    pathbbox 100 100 addPoint 4 2 roll 100 100 subPoint 4 2 roll /setbbox cvx
    % Each partial path segment in the path must be traced independently. Guess
    % that there are at most 100 segments in any path.
    1 1 100 {
	/segmentToTrace exch def
	/inSubpath false def
	1 1 2 {
	    /currentSegment 1 def
	    pop	% Get rid of the for argument
	    /ignoreCycle segmentToTrace currentSegment ne def

	    {		% moveto
		% You should never encounter a moveto in a subpath; it's bad
		% karma. TODO We have to figure out how to deal with multiple
		% subpaths within a path. The way we should do this: break the
		% path up into individual parts, and then run all this stuff on
		% each part.
		ignoreCycle {
		    pop pop
		} {
		    /nowPt defPoint
		    /startPt nowPt defPoint
		} ifelse

	    } {		% lineto
		2 copy /newPt defPoint
		% If the new point equals the old point exactly, then ignore
		% this entire thing.
		newPt nowPt equalPoint ignoreCycle or {
		    pop pop
		} {
		    2 packedarray cvx /linetoArgs exch def
		    inSubpath {			% We're in the subpath.
			/defaultEndSubpath { linetoArgs lineto } def
			lineTestEnd {
			    /inSubpath false def
			    exit
			} {
			    linetoArgs lineto
			} ifelse
		    } {				% We're not in the subpath.
			/defaultStartSubpath {
			    nowPt moveto linetoArgs lineto
			} def
			lineTestStart {
			    /inSubpath true def
			} if
		    } ifelse
		    /nowPt newPt defPoint
		} ifelse

	    } {		% curveto
		2 copy /newPt defPoint
		newPt nowPt equalPoint ignoreCycle or {
		    pop pop pop pop pop pop
		} {
		    6 packedarray cvx /curvetoArgs exch def
		    inSubpath {			% We're in the subpath.
			/defaultEndSubpath { curvetoArgs curveto } def
			curveTestEnd {
			    /inSubpath false def
			    exit
			} {
			    curvetoArgs curveto
			} ifelse
		    } {				% We're not in the subpath.
			/defaultStartSubpath {
			    nowPt moveto curvetoArgs curveto
			} def
			curveTestStart {
			    /inSubpath true def
			} if
		    } ifelse
		    /nowPt newPt defPoint
		} ifelse

	    } {		% closepath
		/newPt startPt defPoint
		/linetoArgs startPt defPoint
		newPt nowPt equalPoint ignoreCycle or not {
		    inSubpath {
			/defaultEndSubpath { linetoArgs lineto } def
			lineTestEnd {
			    /inSubpath false def
			    exit
			} {
			    linetoArgs lineto
			} ifelse
		    } {				% We're not in the subpath.
			/defaultStartSubpath {
			    nowPt moveto linetoArgs lineto
			} def
			lineTestStart {
			    /inSubpath true def
			} if
		    } ifelse
		    /nowPt newPt defPoint
		} if
		/currentSegment currentSegment 1 add def
		/ignoreCycle currentSegment segmentToTrace ne def
	    } pathforall

	    %inSubpath not { exit } if
	} for
	% If the last segment is greater than or equal to the segment we just
	% traced plus one, then the next cycle will be useless so it and all
	% following ones should be canceled.
	currentSegment segmentToTrace 1 add lt { exit } if
    } for

    % Remove the last moveto
    dup /moveto eq {
	pop pop pop
    } if
    ] cvx
    end
} def

/drawSubpath {
    gsave
	currentlinewidth 3 mul setlinewidth
	dup ustroke
    grestore
} def

/useSubpath {
    gsave
	exch newpath uappend
	exec
    grestore
} def

/subpathEndpoint {
    gsave
	newpath uappend currentpoint
    grestore
} def


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Some start and end condition functions
%

% Start when the angle meets some condition.
% {cond} --
/startWhenAngle {
    /StartTestCond exch def
    /lineTestStart {
	nowPt linetoArgs lineAngle StartTestCond {
	    defaultStartSubpath
	    true
	} {
	    false
	} ifelse
    } def
    /curveTestStart {
	nowPt curvetoArgs curveStartAngle StartTestCond {
	    defaultStartSubpath
	    true
	} {
	    false
	} ifelse
    } def
} def

/endWhenAngle {
    /EndTestCond exch def
    /lineTestEnd {
	nowPt linetoArgs lineAngle EndTestCond {
	    defaultEndSubpath
	    true
	} {
	    false
	} ifelse
    } def
    /curveTestEnd {
	nowPt curvetoArgs curveEndAngle EndTestCond {
	    defaultEndSubpath
	    true
	} {
	    false
	} ifelse
    } def
} def

/endBeforeAngle {
    /EndTestCond exch def
    /lineTestEnd {
	nowPt linetoArgs lineAngle EndTestCond {
	    true
	} {
	    false
	} ifelse
    } def
    /curveTestEnd {
	nowPt curvetoArgs curveEndAngle EndTestCond {
	    true
	} {
	    false
	} ifelse
    } def
} def

/endBeforeStartAngle {
    /EndTestCond exch def
    /lineTestEnd {
	nowPt linetoArgs lineAngle EndTestCond {
	    true
	} {
	    false
	} ifelse
    } def
    /curveTestEnd {
	nowPt curvetoArgs curveStartAngle EndTestCond {
	    true
	} {
	    false
	} ifelse
    } def
} def

/startAtPoint {
    /StartPoint defPoint
    /lineTestStart {
	nowPt linetoArgs StartPoint linePtIntc {
	    moveto linetoArgs lineto
	    true
	} {
	    false
	} ifelse
    } def
    /curveTestStart {
	nowPt curvetoArgs StartPoint curvePtIntc {
	    pop pop
	    defaultStartSubpath
	    true
	} {
	    false
	} ifelse
    } def
} def

/endAtPoint {
    /EndPoint defPoint
    /lineTestEnd {
	nowPt linetoArgs EndPoint linePtIntc {
	    lineto
	    true
	} {
	    false
	} ifelse
    } def
    /curveTestEnd {
	nowPt curvetoArgs EndPoint curvePtIntc {
	    pop pop
	    defaultEndSubpath
	    true
	} {
	    false
	} ifelse
    } def
} def

%%EndResource
%%BeginResource: textmgr.ps
%!PS-Adobe-2.0

%
% textmgr.ps
%

% Require: functions.ps

<<
    /TextFont /Helvetica findfont 30 scalefont def
    /TextXPos 0 def
    /TextTopYPos 900 def
    /TextYPos 900 def
    /TextLineSkip 40 def
>>
/TextDict exch def

/resetText {
    TextDict begin
	/TextYPos TextTopYPos def
    end
} def

/setTextPos {
    TextDict begin
	dup /TextTopYPos exch def
	/TextYPos exch def
	/TextXPos exch def
    end
} def

%
% font-dict baselineskip --
/setTextFont {
    TextDict begin
	/TextLineSkip exch def
	/TextFont exch def
    end
} def

%
% (string) number --
/stringOfText {
    gsave TextDict begin
	TextFont setfont
	newpath TextXPos TextYPos moveto
	20 string cvs
	CurrentFile ( = ) append exch append ( # ) append exch append
	TextToConsole { dup = } if
	show
	/TextYPos TextYPos TextLineSkip sub def
    end grestore
} def

/TextToConsole false def
%%EndResource
%%BeginResource: unitalic.ps
%!PS-Adobe-2.0

%
% Takes a font dictionary, makes a new font dictionary that is unitalicized, and
% produces the new font.
%

/unitalic {
    dup /FontInfo get /ItalicAngle get
    dup sin exch cos div % Angle had better not be 90
    [ 1 0 4 -1 roll 1 0 0 ] makefont
} def
%%EndResource
%%BeginResource: width.ps
%!PS-Adobe-2.0
%
% width.ps
%
% Determines the appropriate left width.
%
% This entire file is just one big function. It requires that someone (namely,
% widthlibs.ps) define various values that specify the current letter's width,
% various naming conventions, etc.
%
% Requires: pathtricks.ps points.ps functions.ps drawing.ps

/LeftRightWidth {

% Draw some reference lines
gsave
newpath 0 0 moveto 0 200 lineto stroke
0 100 moveto WidthUnit 100 lineto stroke
rightSidebearing 0 moveto 0 200 rlineto stroke
grestore

/Extremes pathExtremes def
Extremes sortByX firstElt /LeftPoint defPoint
Extremes sortByX lastElt /RightPoint defPoint
Extremes sortByY firstElt /BotPoint defPoint
Extremes sortByY lastElt /TopPoint defPoint
LeftPoint ltpointbox
RightPoint rtpointbox
LeftPoint xcoor /LeftEdge exch def
RightPoint xcoor /RightEdge exch def

0 XHeight SubscriptFraction mul horizLineThrough pathLineIntc
sortByX dup firstElt /HalfwayLeft defPoint lastElt /HalfwayRight defPoint

gsave flattenpath
{ HalfwayLeft startAtPoint HalfwayRight endAtPoint } traceSubpath
{ pathExtremes } useSubpath sortByX lastElt /LowerRightPoint defPoint
grestore
LowerRightPoint rtpointbox
LowerRightPoint xcoor /LowerRightEdge exch def

% Chop the letter up into small slices each HeightUnit high. For each slice,
% look at the x coordinates of the intersection, keeping the smallest and
% largest values. Stuff them into an array.
[
    BotPoint ycoor
    HeightUnit
    TopPoint ycoor {
	/curYcoor exch def
	curYcoor XHeight SubscriptFraction mul HeightUnit withinRange {
	    ] { gt } bubblesort /SubPoints exch def [ SubPoints loadArray
	} if
	curYcoor 0 exch horizLineThrough
	pathLineIntc dup length 0 gt {
	    sortByX dup firstElt xcoor exch lastElt xcoor
	} {
	    pop
	} ifelse
    } for
] /Points exch { lt } bubblesort def

% Sort the array by lowest x coordinate. For coordinate n, shift it outward by
% WidthUnit/n. Of those coordinates, take the one that is farthest out.
LeftEdge ForcedWidth sub
1 1 Points length 2 div MaxUnits min {
    dup 1 sub Points exch get exch
    MaxUnits div WidthUnit mul sub
    min
} for

% Draw a line at that farthest sidebearing point.
gsave 2 setlinewidth newpath
    dup dup BotPoint ycoor moveto TopPoint ycoor lineto
stroke grestore

/LeftPosition exch def LeftPosition % For subscript calculation

doLeft (Left) exch neg AdjustScale round cvi stringOfText

% Reverse the array and do everything again, for the right side.
Points revArray pop

RightEdge ForcedWidth add
1 1 Points length 2 div MaxUnits min {
    dup 1 sub Points exch get exch
    MaxUnits div WidthUnit mul add
    max
} for

gsave 2 setlinewidth newpath
    dup dup BotPoint ycoor moveto TopPoint ycoor lineto
stroke grestore

/RightPosition exch def RightPosition % For subscript calculation

doRight (Right) exch rightSidebearing sub AdjustScale round cvi stringOfText

LowerRightEdge ForcedWidth add
1 1 SubPoints length 2 div MaxSubscriptUnits min {
    dup 1 sub SubPoints exch get exch
    MaxSubscriptUnits div WidthUnit mul add
    max
} for

% The subscript cannot extend past the superscript, and it cannot extend beyond
% the specified subscript indentation limit.
RightPosition min RightPosition MaxSubscriptIndent sub max

gsave 2 setlinewidth newpath
    dup dup BotPoint ycoor moveto XHeight SubscriptFraction mul lineto
stroke grestore

doSubscript (Right subscript) exch rightSidebearing sub AdjustScale round cvi
stringOfText

% Now, try to find the center of the top of the letter.

unmeasurableAcccentLetter {
    pathbbox avgPoint
} {
    % Hack: for T, i, and j, measure from the middle of the letter; all other
    % letters, measure from near the top.
    CurrentLetter (T) eq CurrentLetter (i) eq CurrentLetter (j) eq
    or or { 0.5 } { 0.9 } ifelse
    horizSplitLine pathLineIntc sortByX dup
    firstElt /TopLeft defPoint lastElt /TopRight defPoint
    TopLeft ltpointbox TopRight rtpointbox
    TopLeft TopRight avgPoint
} ifelse

 /TopMiddle defPoint TopMiddle pointbox

% This calculates the proper offset from TopMiddle to the accent position.
TopPoint ycoor TopMiddle ycoor sub dup
currentfont /FontInfo get /ItalicAngle get neg dup sin exch cos div mul exch
TopMiddle addPoint /AccentPoint defPoint

AccentPoint pointbox
mark AccentPoint TopMiddle drawLine cleartomark

AccentPoint xcoor RightPosition LeftPosition add 2 div sub

doAccent (Accent point) exch AdjustScale round cvi stringOfText

% In the case of the letters i and j, output the resulting widths so that we can
% calculate the values for the dotless j, even if it doesn't exist.
(i) CurrentLetter eq (j) CurrentLetter eq or {
    /CurrentFile CurrentLetter (-width) append def
    (Width) RightPosition LeftPosition sub AdjustScale round cvi stringOfText
} if

% In the case of the letter i, also do dotless i
(i) CurrentLetter eq {
    gsave 20 dict begin
	0 1 currentfont /Encoding get length 1 sub {
	    dup currentfont /Encoding get exch get /dotlessi eq {
		/DotlessiPos 1 string def
		DotlessiPos exch 0 exch put
		/rightSidebearing { DotlessiPos stringwidth pop } def
		/CurrentLetter (dotlessi) def
		400 0 translate
		DotlessiPos letterPath
		LeftRightWidth
		exit
	    } {
		pop
	    } ifelse
	} for
    end grestore
} if

} def

% Auxiliary function to find letters that should not be measured for the top
% point (instead, the middle of the box should be used). Although it is highly
% unlikely, you may wish to change this list as necessary. In fact, this list
% really should be located somewhere else!
/unmeasurableAcccentLetter {
    false
    UnmeasurableLetters {
	CurrentLetter eq { pop true exit } if
    } forall
} def

/UnmeasurableLetters [ (C) (E) (F) (G) (S) (Z) (a) (c) (e) (o) (r) (z) ] def

% Helper functions in qualities of letters
/doLeft { /CurrentFile { CurrentLetter (-left) append } def } def
/doRight { /CurrentFile { CurrentLetter (-right) append } def } def
/doSubscript { /CurrentFile { CurrentLetter (-subscript) append } def } def
/doAccent { /CurrentFile { CurrentLetter (-accent) append } def } def
/rightSidebearing { CurrentLetter stringwidth pop } def

%%EndResource
%%BeginResource: superness.ps
%
% superness.ps
%
% Functions to determine superness parameters.
%
% Requires: points.ps pathtricks.ps functions.ps
%

% Given a horizontal extreme point and a vertical extreme point and a boolean
% for whether to use the outer or inner intersection point, calculate the points
% relevant to superness.
/findSupernessPoints {
    10 dict begin
	/Outer exch def
	/vertPoint defPoint /horizPoint defPoint
	vertPoint xcoor horizPoint ycoor /Corner defPoint
	horizPoint xcoor vertPoint ycoor /Center defPoint
	Corner pointbox Center  pointbox
	Center Corner pathLineIntc sortByX
	Center xcoor Corner xcoor gt { revArray } if
	dup length 1 gt {
	    dup length 2 sub 2 getinterval
	    Outer { 1 } { 0 } ifelse
	} {
	    0
	} ifelse
	get /SuperPoint defPoint
	SuperPoint pointbox
	Center Corner SuperPoint
    end
} def

% Given a center, a corner, and a superness intersection point, determine the
% superness.
/findSuperness {
    3 dict begin
	/SuperPoint defPoint /Corner defPoint /Center defPoint
	SuperPoint Center subPoint magnitude
	Corner Center subPoint magnitude
	div
    end
} def
%%EndResource
%%EndProlog
%%BeginSetup
% THE FONT
/Palatino-Italic findfont 1000 scalefont setfont
/doTranslation {
    50 200 translate
    0.6 0.6 scale
} def

/resetPage {
    doTranslation
    resetExtremes
    resetIntc
    resetText
} def


% Measure height of path
gsave
    nulldevice
    0 0 moveto (x) true charpath flattenpath
    pathbbox /XHeight exch def pop pop pop
grestore

/TextToConsole true def
/WidthUnit 1000 18 div def
/ForcedWidth WidthUnit 5 div def
/HeightUnit 25 def
/SubscriptFraction 0.5 def
/MaxUnits 7 def
/MaxSubscriptUnits 5 def
/MaxSubscriptIndent 250 def
/AdjustScale { } def
%%EndSetup
%%Page: 1 1
resetPage
/CurrentLetter (a) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 2 2
resetPage
/CurrentLetter (b) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 3 3
resetPage
/CurrentLetter (c) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 4 4
resetPage
/CurrentLetter (d) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 5 5
resetPage
/CurrentLetter (e) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 6 6
resetPage
/CurrentLetter (f) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 7 7
resetPage
/CurrentLetter (g) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 8 8
resetPage
/CurrentLetter (h) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 9 9
resetPage
/CurrentLetter (i) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 10 10
resetPage
/CurrentLetter (j) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 11 11
resetPage
/CurrentLetter (k) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 12 12
resetPage
/CurrentLetter (l) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 13 13
resetPage
/CurrentLetter (m) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 14 14
resetPage
/CurrentLetter (n) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 15 15
resetPage
/CurrentLetter (o) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 16 16
resetPage
/CurrentLetter (p) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 17 17
resetPage
/CurrentLetter (q) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 18 18
resetPage
/CurrentLetter (r) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 19 19
resetPage
/CurrentLetter (s) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 20 20
resetPage
/CurrentLetter (t) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 21 21
resetPage
/CurrentLetter (u) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 22 22
resetPage
/CurrentLetter (v) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 23 23
resetPage
/CurrentLetter (w) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 24 24
resetPage
/CurrentLetter (x) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 25 25
resetPage
/CurrentLetter (y) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 26 26
resetPage
/CurrentLetter (z) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 27 27
resetPage
/CurrentLetter (A) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 28 28
resetPage
/CurrentLetter (B) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 29 29
resetPage
/CurrentLetter (C) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 30 30
resetPage
/CurrentLetter (D) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 31 31
resetPage
/CurrentLetter (E) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 32 32
resetPage
/CurrentLetter (F) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 33 33
resetPage
/CurrentLetter (G) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 34 34
resetPage
/CurrentLetter (H) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 35 35
resetPage
/CurrentLetter (I) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 36 36
resetPage
/CurrentLetter (J) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 37 37
resetPage
/CurrentLetter (K) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 38 38
resetPage
/CurrentLetter (L) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 39 39
resetPage
/CurrentLetter (M) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 40 40
resetPage
/CurrentLetter (N) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 41 41
resetPage
/CurrentLetter (O) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 42 42
resetPage
/CurrentLetter (P) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 43 43
resetPage
/CurrentLetter (Q) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 44 44
resetPage
/CurrentLetter (R) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 45 45
resetPage
/CurrentLetter (S) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 46 46
resetPage
/CurrentLetter (T) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 47 47
resetPage
/CurrentLetter (U) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 48 48
resetPage
/CurrentLetter (V) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 49 49
resetPage
/CurrentLetter (W) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 50 50
resetPage
/CurrentLetter (X) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 51 51
resetPage
/CurrentLetter (Y) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Page: 52 52
resetPage
/CurrentLetter (Z) def
CurrentLetter letterPath
LeftRightWidth

showpage
%%Trailer
%%Pages: 52
%%EOF
